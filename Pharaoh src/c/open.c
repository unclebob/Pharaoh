/* * opening.c -- This file contains the code which drives the openning sequence  */ #include <std.h>#include <quickdraw.h>#include <resource.h>#include <textedit.h>#include <window.h>#include <event.h>#include <memory.h>#include <font.h>#include "skel.h"#include "pharaoh.h"#include "strings.h"#define ZOOMTIME  45	/* ZoomRect time *//* * States of the open function */ #define S_IDLE 	0	/* the opener is idling */#define S_GROW	1	/* expand the current edit window */#define S_SHRINK	2	/* shrink the current edit window */#define S_NEXT	3	/* update the edit record for the next page */#define S_END	4	/* clean up, and go away */#define S_INIT	5	/* initialization state *//*  * External functions  */  TEXT *malloc();/* * Local Variables */ LOCAL WindowRecord openWindow;LOCAL BitMap *editBits;LOCAL Rect editDest;LOCAL TEHandle hTE;	/* edit record */LOCAL BITS state = S_INIT;	/* Initialize */LOCAL Rect big, small, current;	/* rectangles define states of edit window growth */LOCAL LONG time;LOCAL Rect openBounds;		/* rectangle for open window */LOCAL GrafPtr editPort;IMPORT BOOL speechFlag;GLOBAL BOOL pgmLocked = YES;/*«Initialize Opening * Opening -- Begin the opening procedure */ VOID Opening()	{	LOCAL WindowControl openWC;	Rect logoRect, gLogoRect;	Rect nullRect, gNullRect;	LONG junk;	PicHandle pic;	FAST COUNT nWords, nRows;	TEXT **textHandle;	VOID OpenCursor(), OpenIdle(), OpenMouse(), OpenUpdate();	/* Initialize the WindowControl structure */	fill(&openWC,sizeof(openWC), NULL);	openWC.windowCursor = 	&OpenCursor;	openWC.windowIdle =	&OpenIdle;	openWC.windowMouse =	&OpenMouse;	openWC.windowUpdate = 	&OpenUpdate;		/* create the opening window */	openBounds = screenBits.bounds;	InsetRect(&openBounds, 60, 50);	NewWindow(&openWindow, &openBounds, "\PClick to Continue", TRUE, rDocProc, -1L,				FALSE, &openWC);			/* Prepare the logo */	SetPort(&openWindow);	FillRect(&openWindow.port.portRect, &ltGray);	pic = GetResource('PICT', LOGO_PICT);	logoRect = (**pic).picFrame;	CenterRect(&logoRect);	SetRect(&nullRect, 0,0,1,1);	/* smallest rectangle */	CenterRect(&nullRect);	gNullRect = nullRect;	gLogoRect = logoRect;	RLocalToGlobal(&gNullRect);	RLocalToGlobal(&gLogoRect);		/* zoom from Null and display logo, then zoom back to Null */	ZoomRect(&gNullRect, &gLogoRect, ZOOMTIME);	DrawPict(pic, &logoRect);	if (speechFlag)		SaySt(VC_WELCOME);	else		Delay(3*60L, &junk);	FillRect(&logoRect, &ltGray);	ZoomRect(&gLogoRect, &gNullRect, ZOOMTIME);	ReleaseResource(pic);	/* create the GrafPort for the Edit data */	editPort = malloc(sizeof(GrafPort));	OpenPort(editPort);	editBits = &(editPort->portBits);	editBits->bounds = openBounds;	editBits->bounds.right -= editBits->bounds.left;	editBits->bounds.bottom -= editBits->bounds.top;	editBits->bounds.top = editBits->bounds.left = 0;		/* calculate editPort Bitmap */	{	COUNT rowWords, rows;	rowWords = (editBits->bounds.right + 15)/16;	/* even one bit deserves a word */	rows = editBits->bounds.bottom;	editBits->rowBytes = rowWords * 2;	editBits->baseAddr = malloc(editBits->rowBytes * rows);	}		/* set up the edit rectangles */	editDest = editBits->bounds;	InsetRect(&editDest, 5, 5);	/* edit Rectangle just inside window boundaries */	SetPort(editPort);	TextFont(monaco);	TextSize(9);	TextFace(0);		/* Now set up the Edit Record and "draw" the text into the special editPort */	hTE = TENew(&editDest, &editDest);	HLock(hTE);	if ( ((textHandle  = GetResource('TEXT', PERS_ID)) == NIL) &&	      ((textHandle  = GetResource('TEXT', OPEN_ID)) == NIL))		{		MessageAlert("The Pharaoh game has been corrupted.");		exit();		}	(**hTE).hText = textHandle;	HUnlock(hTE);	if (DeCrypt(textHandle) == NO)		{		MessageAlert("The Pharaoh program file has been corrupted..");		exit();		}	TECalText(hTE);	EraseRect(&editDest);	TEUpdate(&editDest, hTE);	SetPort(&openWindow);	big = editDest;	/* the biggest size of the edit rectangle */	CenterRect(&big);	SetRect(&small, 0,0,1,1);		/* the smallest possible rectangle */	CenterRect(&small);	current = small;	time = TickCount();	FlushEvents(everyEvent, 0);	InvalRect(&openWindow.port.portRect);	/* start updating the window */	}/* * Make sure the cursor is an arrow */ VOID OpenCursor(w, p, code)FAST WindowRecord *w;Point p;FAST BITS code;	{	SetCursor(&arrow);	}/*«OpenIdle» * OpenIdle -- Do the dynamics of the growing and shrinking */ VOID OpenIdle(w)FAST WindowRecord *w;	{	LOCAL LONG timeDelta;	Rect oldCurrent;		timeDelta = TickCount() - time;	time += timeDelta;	timeDelta += timeDelta/2;	/* move at 1.5 real rate */		switch (state)		{		RgnHandle rgn;		Rect inval;				case S_IDLE:			return;			break;				case S_GROW:			rgn = NewRgn();			oldCurrent = current;			current.top -= min(timeDelta, current.top - big.top);			current.bottom += min(timeDelta, big.bottom - current.bottom);			current.right += min(timeDelta, big.right - current.right);			current.left -= min(timeDelta, current.left - big.left);			SetPort(&openWindow);			OpenRgn();			FrameCurtain(&current);			CloseRgn(rgn);			InvalRgn(rgn);						if (EqualRect(&current, &big))				state = S_IDLE;			DisposeRgn(rgn);			break;					case S_SHRINK:			rgn = NewRgn();			SetPort(&openWindow);						inval = current;			InsetRect(&inval, -1,-1);			InvalRect(&inval);			current.top += 	min(timeDelta, small.top - current.top);			current.bottom -= min(timeDelta, current.bottom - small.bottom);			current.right -= min(timeDelta, current.right - small.right);			current.left += min(timeDelta, small.left - current.left);			OpenRgn();			FrameCurtain(&current);			CloseRgn(rgn);			ValidRgn(rgn);			if (EqualRect(&current,&small) || EmptyRect(&current))				state = S_NEXT;			DisposeRgn(rgn);			break;				case S_NEXT:			(**hTE).destRect.top -= ScrollSize(); /* move destRect up */			if ((**hTE).viewRect.top - (**hTE).destRect.top > 			((**hTE).lineHeight * (**hTE).nLines))				state = S_END;			else				{				state = S_GROW;				current = small;				}			SetPort(editPort);			TEUpdate(&editDest, hTE);			SetPort(w);			break;				case S_END:			TEDispose(hTE);			CloseWindow(&openWindow);			free(editBits->baseAddr);			free(editPort);			SetPort(FrontWindow());			InvalRect(&screenBits.bounds);			break;		}	}/*«ScrollSize» * ScrollSize -- calculate how much to scroll the open window down by.  This should be an  *                      integral number of lines, somewhat less than a complete screenful */ LOCAL COUNT ScrollSize()	{	FAST COUNT openHeight, lineHeight, nLines, scrollSize;		openHeight = editDest.bottom - editDest.top;	lineHeight = (**hTE).lineHeight;		nLines = openHeight / lineHeight;	/* number of lines in window */	nLines--;						/* don't do a complete windows worth */	scrollSize = nLines * lineHeight;	/* calculate scrollSize in bits */ 	return(scrollSize);	}	/*«OpenMouse» * OpenMouse --  The mouse is down in the open window */ VOID OpenMouse(w, e, code)FAST WindowRecord *w;FAST EventRecord *e;FAST BITS code;	{	if (code == inDrag)		SelectWindow(w);	else if (code == inContent && state == S_IDLE)		state = S_SHRINK;	}	VOID OpenUpdate(w,e)FAST WindowRecord *w;FAST EventRecord *e;	{	SetPort(w);	BeginUpdate(w);	if (state == S_INIT)		{		FillRect(&openWindow.port.portRect, &ltGray);		state = S_GROW;	/* start the ball rolling */		}	else if (state == S_GROW || state == S_IDLE)		{		Rect srcRect, dstRect;		RgnHandle rgn;		Point p;				SetPt(&p, 0, 0);		LocalToGlobal(&p);		rgn = NewRgn();		CopyRgn(w->port.visRgn, rgn);		OffsetRgn(rgn, p.h, p.v);		srcRect = (**(w->port.visRgn)).rgnBBox;		dstRect = srcRect;		RLocalToGlobal(&dstRect);		CopyBits(editBits, &screenBits, &srcRect, &dstRect, srcCopy, rgn);		DisposeRgn(rgn);		}	else		FillRectRect(&openWindow.port.portRect, &ltGray);	EndUpdate(w);	}		/*«FrameCurtain»  * FrameCurtain -- draw the outline of the curtain which opens and closes accross the window  */ #define ROOT3_3 	577		/* 0.577 */#define ROOT3_2	866 		/* 0.866 */#define ONE		1000L	/* 1.000 */VOID FrameCurtain(r)Rect *r;	/* the curtain must be the smallest which completely encloses the rectangle */	{	FrameRoundRect(r, 25, 25);	}		/*«DeCrypt»  * DeCrypt -- Try to decode the opening text  *			returns YES if the openning text was in the proper format.  */  BOOL DeCrypt(h)FAST TEXT **h;	{	union		{		LONG l;		TEXT t[5];		} ltot;		LONG key, cSum, CSum();	COUNT hSize;	LONG *lp;		HLock(h);	hSize = GetHandleSize(h) - 4;		lp = *h + hSize;	key = *lp;	ltot.l = ~key;	ltot.t[4] = NULL;	Crypt(*h, hSize, ltot.t,4);	cSum = CSum(*h, hSize);	if (cSum == ~key)		pgmLocked = NO;	else if (cSum != key)		{		return(NO);		}	HUnlock(h);	SetHandleSize(h, (Size)hSize);	return(YES);	}