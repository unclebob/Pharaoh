/*  * RandomEvent.c -- generate random events to annoy the player  */  #include <std.h>#include <math.h>#include "random.h"#include "vars.h"#include "strings.h"#include "interpolate.h"RandomEvent()	{	COUNT whichEvent;		whichEvent = URandom(0.0,100.0);	if (whichEvent < 2)		Locusts();	else if (whichEvent < 6)		Plagues();	else if (whichEvent < 8)		ActsOfGod();	else if (whichEvent < 20)		ActsOfMobs();	else if (whichEvent < 21)		War();	else if (whichEvent < 30)		Revolt();	else if (whichEvent < 45)		WorkLoad();	else if (whichEvent < 60)		HealthEvents();	else if (whichEvent < 65)		LaborEvent();	else if (whichEvent < 75)		WheatEvent();	else if (whichEvent < 85)		GoldEvent();	else if (whichEvent < 100)		EconomyEvent();	}/*ÇLocusts devour cropÈ  * Locusts Devour Crop  */  Locusts()	{	TEXT template[256];		if (lnFallow+lnGrown+lnRipe+lnSewn == 0.0)		return;	GetCString(template, TM_LOCUSTS);	WarningAlert(template);	lnFallow += lnSewn + lnGrown + lnRipe;	lnSewn = lnGrown = lnRipe = 0;	wtSewn = wtGrown = wtRipe = 0;	wkAddition = 15 * slaves + 				GRandom(5.0, 1.0) * (lnFallow+lnSewn+lnGrown+lnRipe);	}	/*ÇPlaguesÈ  * Plagues  */  VOID Plagues()	{	TEXT template[256],disease[256], wrk[256];		if (slaves+oxen+horses == 0.0)		return;			GetCString(disease, ST_PLAGUES);	GetCString(template,TM_PLAGUES);	sprintf(wrk, template, disease);	WarningAlert(wrk);		slHealth *= 	URandom(.2, .9);	oxHealth *=	URandom(.2, .9);	hsHealth *=	URandom(.2, .9);	slaves *=		URandom(.7, .95);	oxen *=		URandom(.7, .95);	horses *=		URandom(.7, .95);	}	/*ÇActsOfGodÈ  * ActsOfGod  */  VOID ActsOfGod()	{	TEXT template[256], adj[256], what[256], does[256], msg[256];	DOUBLE k;		GetCString(template, TM_AOG);	GetCString(adj, ST_AOGADJ);	GetCString(what, ST_AOGWHAT);	GetCString(does, ST_AOGDOES);	sprintf(msg, template, adj, what, does);	WarningAlert(msg);		lnFallow *= URandom(.3, .8);		k = URandom(.3, .8);	lnGrown *= k;	wtGrown *= k;		k = URandom(.3, .8);	lnSewn *= k;	wtSewn *= k;		k = URandom(.3, .8);	lnRipe *= k;	wtRipe *= k;		slaves *=	URandom(.3, .8);	oxen *=	URandom(.3, .8);	horses *=	URandom(.3, .8);	wheat *=	URandom(.3, .8);	manure *=URandom(.3, .8);		wkAddition = GRandom(11.,3.) * slaves + 				GRandom(5.0, 1.0) * (lnFallow+lnSewn+lnGrown+lnRipe);	}	/*ÇActsOfMobsÈ  * ActsOfMobs  */  VOID ActsOfMobs()	{	TEXT template[256], adj[256], who[256], motive[256], does[256], msg[256];	DOUBLE k;		GetCString(template, TM_AOM);	GetCString(adj, ST_AOMADJ);	GetCString(who, ST_AOMWHO);	GetCString(motive, ST_AOMMOT);	GetCString(does, ST_AOMDOES);	sprintf(msg, template, adj, who, motive, does);	WarningAlert(msg);		wtGrown *= 	URandom(.6, .8);	wtSewn  *= 	URandom(.6, .8);	wtRipe *= 	URandom(.6, .8);		slaves *=	URandom(.6, .8);	oxen *=	URandom(.6, .8);	horses *=	URandom(.6, .8);	wheat *=	URandom(.6, .8);	manure *=URandom(1.05, 1.20);	manure += URandom(lnTotal*.5, lnTotal*3);		/* a certain extra work per slave, and work per acre */	wkAddition = URandom(5., 10.) * slaves + 				GRandom(5.0, 1.0) * (lnFallow+lnSewn+lnGrown+lnRipe);	}	/*ÇWarÈ  * War  */  VOID War()	{	TEXT template[256], who[256],  what[256], msg[256];	DOUBLE myArmy, hisArmy, myDice, hisDice, gain, maxGain;	FAST COUNT pct;		GetCString(template, TM_WAR);	GetCString(who, ST_WARWHO);		myArmy = overseers+1;	/* no zeroes please */	hisArmy = (min(1e5, overseers) * ARandom(1.0, 0.2)) + 1;	myDice = myArmy * ARandom(1.0, 0.3);	hisDice = hisArmy * ARandom(1.0, 0.3);	if (hisDice < .001)		gain = 0;	/* prevent infinities */	else		gain = myDice / hisDice;			maxGain = (hisArmy+myArmy)/myArmy; /* the most you can win */	gain = min(gain, maxGain);		pct = (gain - 1) * 100;	pct = abs(pct);		GetCString(what, gain<1 ? ST_WARLOSE : ST_WARWON);	sprintf(msg, template, who, what, pct);	WarningAlert(msg);		lnFallow 	*= 	gain * ARandom(1.0, 0.2);	lnGrown 	*= 	gain * ARandom(1.0, 0.2);	wtGrown 	*= 	gain * ARandom(1.0, 0.2);	lnSewn 	*= 	gain * ARandom(1.0, 0.2);	wtSewn 	*= 	gain * ARandom(1.0, 0.2);	lnRipe 	*= 	gain * ARandom(1.0, 0.2);	wtRipe 	*= 	gain * ARandom(1.0, 0.2);	slaves 	*=	gain * ARandom(1.0, 0.2);	oxen 	*=	gain * ARandom(1.0, 0.2);	horses 	*=	gain * ARandom(1.0, 0.2);	wheat 	*=	gain * ARandom(1.0, 0.2);	manure 	*=	gain * ARandom(1.0, 0.2);		wkAddition = GRandom(15.0, 3.0) * slaves + hisArmy*GRandom(5.0, 1.0);	}/*ÇRevoltÈ  * The Slaves revolt  */  VOID Revolt()	{	TEXT template[256], msg[256];	DOUBLE suffering, sickness, hatred, destruction, gain;	FAST COUNT pct;	LOCAL Table		tSuffering =	{0.0, 1.0, /* slLashRt */					0.0, .01, .02, .1, .2, .4, .6, .9, .95, .98, 1.0},							tSickness =	{0.0, 1.0, /* slHealth */					1.0, .95, .9, .8, .4, .2, .1, .04, .02, .01, 0.0},				tDestruction =	{0.0, 1.0,	/* hatred */					0, 0.01, 0.03, 0.08, 0.15, 0.25, 0.4, 0.6, 0.9, 0.95, 1.0};		if (slaves == 0)		return;			GetCString(template, TM_REVOLT);		suffering = 	interpolate(slLashRt, &tSuffering);	sickness = 	interpolate(slHealth, &tSickness);	hatred = 		(suffering + sickness)/2;	destruction =	interpolate(hatred, &tDestruction) * ARandom(1.0, .2);	gain = 		1-destruction;	gain = 		max(gain, 0);	gain = 		min (gain, 1);	pct = (gain - 1) * 100;	pct = abs(pct);		sprintf(msg, template, pct);	WarningAlert(msg);		lnFallow 	*= 	gain;	lnGrown 	*= 	gain;	wtGrown 	*= 	gain;	lnSewn 	*= 	gain;	wtSewn 	*= 	gain;	lnRipe 	*= 	gain;	wtRipe 	*= 	gain;	slaves 	*=	gain;	oxen 	*=	gain;	horses 	*=	gain;	wheat 	*=	gain;	manure 	*=	gain;		/* it takes a hell of alot of time to revolt, and a big investment to overcome overseers */	wkAddition = GRandom(18.0, 3.0) * slaves + GRandom(30.0, 5.0) * overseers;	}/*ÇWorkLoadÈ  * Workload Events  */  VOID WorkLoad()	{	TEXT template[256], wrk[256], amount[50];	DOUBLE wkValue;	TEXT  *wkUnit;		if (slaves == 0.0)		return;			GetCString(template, TM_WORKLOAD);		wkAddition = 	GRandom(10., 3.0) * slaves  + 				GRandom(8.0, 2.0) * (lnFallow+lnSewn+lnGrown+lnRipe);		wkValue = wkAddition;	/* man hours per day */	wkValue *= 30;		/* man hours this month */	if (wkValue < 1e5)		wkUnit = " man hours";	else if ((wkValue /= 24) < 1e4)		wkUnit = " man days";	else if ((wkValue /= 30) < 1e4)		wkUnit = " man months";	else if ((wkValue /= 12) < 1e4)		wkUnit = " man years";	else if ((wkValue /= 10) < 1e5)		wkUnit = " man decades";	else if ((wkValue /= 10) < 1e5)		wkUnit = " man centuries";	else if ((wkValue /= 10) < 1e8)		wkUnit = " man millenia";	else		{		wkValue = 1;		wkUnit = "hell of a lot of labor";		}		ftoa(wkValue, amount, 0, 1);	strcat(amount, wkUnit); 	sprintf(wrk, template, amount);	WarningAlert(wrk);	}/*ÇHealthEventsÈ  * Health Events  */  VOID HealthEvents()	{	TEXT template[256];		if (slaves + oxen + horses == 0.0)		return;		GetCString(template, TM_HEALTH);	WarningAlert(template);		slHealth *=		GRandom(.6, .1);	oxHealth *=		GRandom(.6, .1);	hsHealth *=		GRandom(.6, .1);	}		/*ÇLaborEventÈ  * Labor Events  */  VOID LaborEvent()	{	TEXT template[256], msg[256];	DOUBLE raise;	COUNT raisePct;		if (overseers == 0.0)		return;			GetCString(template, TM_LABOR);		raise = GRandom(1.20, .05);	raise = max(raise, 1.01);	raisePct = (raise-1) * 100;	sprintf(msg, template, raisePct);	WarningAlert(msg);		ovPay *= raise;	overseers *= GRandom(.9, .03);	overseers = floor(overseers);		ovStress += GRandom(.5, .1);	}/*ÇWheatEventÈ  * Wheat events  */  VOID WheatEvent()	{	TEXT template[256], msg[256];	DOUBLE loss;	COUNT lossPct;		if (lnSewn+lnGrown+lnRipe == 0.0)		return;			GetCString(template, TM_WHEAT);	loss = GRandom(.7, .07);	loss = min(loss, .99);	lossPct = (1-loss)*100;	sprintf(msg, template, lossPct);	WarningAlert(msg);	wheat *= loss;	wtSewn *= loss;	wtGrown *= loss;	wtRipe *= loss;	}/*ÇGoldEventÈ  * Gold Events  */  VOID GoldEvent()	{	TEXT template[256], msg[256];	DOUBLE loss;	COUNT lossPct;		if (gold==0.0)		return;			GetCString(template, TM_GOLD);	loss = GRandom(.65, .1);	loss = min(loss, .99);	lossPct = (1-loss)*100;	sprintf(msg, template, lossPct);	WarningAlert(msg);	gold *= loss;	}/*ÇEconomyEventÈ  * Economy Events  */  VOID EconomyEvent()	{	TEXT template[256];		GetCString(template, TM_ECONOMY);	WarningAlert(template);		wtPrice *= 	GRandom(1.0, .15);	oxPrice  *=	GRandom(1.0, .15);	hsPrice *=	GRandom(1.0, .15);	slPrice *=	GRandom(1.0, .15);	mnPrice *=	GRandom(1.0, .15);		inflation +=	GRandom(0.0, .01);	}