/* * Compute the values of the Pharaoh variables for 1 month */ #include <std.h>#include <math.h>#include "vars.h"#include "random.h"#include "strings.h"#define CLIP(x) 	((x)<0 ? 0 : (x))VOID RunMonth()	{	DOUBLE k1, k2;		/* general working variables */	DOUBLE PyHeight(), newPyHeight,avgPyHeight,pyWk,debtLimit;		/* 	  * Compute time	  */	if (++month > 12)		{		month = 1;		year++;		}			/*	  * Compute some basic ratios and factors	  */	 	ox_sl = 		slaves ? oxen/slaves : 0;	sl_ov = 		slaves / (overseers + 1);	/* count the pharaoh as a permanent overseer */	hs_ov = 		overseers ? horses/overseers : 0;		mnSpread = mnToSprd;	if (mnToSprd > manure)	 	mnSpread = manure;	mn_ln =	 mnSpread/lnToSew;		/*	  * Compute potential pyramid growth	  */	  	newPyHeight = PyHeight(pyBase, pyStones + pyQuota);	avgPyHeight = ceil((pyHeight + newPyHeight)/2);		 	/*	  * Compute montly workload in man-hours per day	  */	 	wkOxTend = 	oxen * 1; 	wkMnSprd = 	mnToSprd * 64; 	wkWtSew = 	lnToSew * 30;	wkWtTend = 	lnSewn * 20 + lnGrown * 15;	wkWtHvst = 	wtRipe * .1 + lnRipe * 20;	wkHsTend = 	horses * 1;	pyWk = 		pyQuota * avgPyHeight * 12;	reqWk = 		wkOxTend + wkMnSprd + wkWtSew + wkWtHvst + 				wkWtTend + wkHsTend + pyWk + wkAddition;	reqWk *= 	ARandom(1., 0.1);	/* randomize */	reqWk_sl = 	slaves ? reqWk/slaves : 0;	wkAddition = 	0;	/* reset the temporary addition */		/*	  * What are the ramifications of slave health this month	  */		slDthK = 		interpolate(slHealth, &tSlDthK) * ARandom(1., 0.1);	slBrthK = 		interpolate(slHealth, &tSlBrthK) * ARandom(1., 0.1);	wkAble_sl = 	interpolate(slHealth, &tWkAble_sl) * ARandom(1., 0.1);		/*	  * And what about Horse Health	  */		hsEff = 		interpolate(hsHealth, &tHsEff) * ARandom(1., 0.1);	hsDthK = 		interpolate(hsHealth, &tHsDthK) * ARandom(1., 0.1);	hsBrthK = 	interpolate (hsHealth, &tHsBrthK) * ARandom(1., 0.1);		/*	  * and also oxen health	  */	 	oxEff = 		interpolate(oxHealth, &tOxEff) * ARandom(1., 0.1);	oxDthK = 		interpolate(oxHealth, &tOxDthK) * ARandom(1., 0.1);	oxBrthK = 	interpolate(oxHealth, &tOxBrthK) * ARandom(1., 0.1);		/*	  * Now how are the overseers doing	  */	 	hsEff_ov = 	hs_ov * hsEff;	ovEff = 		interpolate(hsEff_ov, &tOvEff) * ARandom(1., 0.1);	ovEff_sl = 	sl_ov ? (ovEff / sl_ov) : 0;	 	/*	  * Are they abusing the slaves?	  */	 	stressLash =	interpolate(ovPress, &tStressLash) * ARandom(1., 0.1);	slLashRt = 	stressLash * ovEff_sl;	 	/*	  * Are the slaves motivated?	  */	  	posMotive = 	interpolate(ovEff_sl, &tPosMotive) * ARandom(1., 0.1);	negMotive = 	interpolate(slLashRt, &tNegMotive);	motive = 		posMotive + negMotive;	 	/*	  * How can the Oxen help the slaves	  */	  	oxMultK = 	interpolate(ox_sl, &tOxMultK);	oxMult = 		max(oxMultK*oxEff, 1);	 	/*	  * so then, how many man hours per day can a slave produce?	  */	  	maxWk_sl = 	motive * wkAble_sl * oxMult;	 	/*	  * how does this compare with the required workload?	  */	  	wk_sl = 		min(maxWk_sl, reqWk_sl);	wkDeff_sl = 	(wk_sl < reqWk_sl) ? (reqWk_sl - wk_sl) : 0;	totWk = 		wk_sl * slaves;	slEff = 		reqWk ? (totWk / reqWk) : 1;	 	 	/*	  * Now build the pyramid	  */	  	pyAdded = pyQuota * slEff;	pyStones += pyAdded;	newPyHeight = PyHeight(pyBase, pyStones);	avgPyHeight = ceil((newPyHeight + pyHeight)/2);	if ((newPyHeight - pyHeight) > .02)		InvalPyramid(pyHeight, newPyHeight, pyBase);	pyHeight = newPyHeight;		/*	  * Lets tend the animals  (how much are the slaves able to feed them?)	  */	  	oxFed = 		oxFeedRt * slEff;	hsFed = 		hsFeedRt * slEff;	slFed = 		slFeedRt;	  	/*	  * How much wheat are we going to use this month	  */	sewRt = 		lnToSew*slEff; /* based on slave workload */	sewRt = 		min(sewRt, lnFallow);	/* adjust for available land */		wtToSew = 	wtSewn_ln * sewRt;	wtFedHs = 	hsFed * horses * slEff;	wtFedOx = 	oxFed * oxen * slEff;	wtFedSl = 	slaves * slFeedRt;	wtRotted = 	wheat * (wtRotRt * ARandom(1., 0.1));	totWtUsed = 	wtToSew + wtFedHs + wtFedOx + wtFedSl;		/* if we don't have enough wheat, adjust all the variables proporionally */		wtEff = 1.0;	if ((wheat - wtRotted) < totWtUsed)		{		wtEff = totWtUsed ? 			((wheat - wtRotted)/ totWtUsed) : 	/* what we have, vs. what we need */			1.0; 		wtToSew *= wtEff;		wtFedHs *= wtEff;		wtFedOx *= wtEff;		wtFedSl *= wtEff;		oxFed *= wtEff;		hsFed *= wtEff;		slFed *= wtEff;		totWtUsed *= wtEff;		sewRt = sewRt * wtEff;		}	  	wtEaten = 	wtFedSl + wtFedOx + wtFedHs;	totWtUsed += wtRotted;		/*	  * Now lets look at the planting cycle for the land	  */	  	lnGrowRt = 	lnSewn;	lnRipeRt = 	lnGrown;	lnHvsted = 	lnRipe;		lnFallow += 	lnHvsted - sewRt;	lnSewn += 	sewRt - lnGrowRt;	lnGrown +=	lnGrowRt - lnRipeRt;	lnRipe +=		lnRipeRt - lnHvsted;		lnTotal = lnFallow + lnSewn + lnGrown + lnRipe;		 /*	   * the Manure store house	   *     For every 100 bushells of wheat that are eaten, about 1 ton of manure is produced.	   */	mnMade = 	wtEaten / 100 * ARandom(1., 0.1);		mnSpread *= 	slEff;	mnUsed = 		mnSpread;	manure +=	(mnMade - mnUsed);	manure = CLIP(manure);		/*	  * Now lets tend the fields	  */	  	wtYeild = 	interpolate(mn_ln, &tWtYeild) * 					ARandom(1., 0.1) * 					interpolate((DOUBLE)month, &tSeasonYeild);  	wtSewRt = 	wtYeild * wtToSew;	wtGrowRt = 	wtSewn;	wtRipeRt = 	wtGrown;	sythed = 		wtRipe * slEff;	wtLost = 		(1-slEff)*wtRipe;		wtSewn += 	(wtSewRt - wtGrowRt);	wtGrown +=	(wtGrowRt - wtRipeRt);	wtRipe +=		(wtRipeRt - sythed - wtLost);		/*	  * Now lets adjust the wheat store house	  */	  	wtHrvstd = 	sythed;	wtUsageRt = 	totWtUsed;	wheat +=		(wtHrvstd - wtUsageRt);	wheat = CLIP(wheat);	 	/*	  * now lets do the populations	  */	  	slBrthRt = 	slBrthK * slaves;	slDthRt = 		slDthK * slaves;	slaves +=		(slBrthRt - slDthRt);	slaves = CLIP(slaves);		oxBrthRt = 	oxBrthK * oxen;	oxDthRt = 	oxDthK * oxen;	oxen +=		(oxBrthRt - oxDthRt);	oxen = CLIP(oxen);		hsBrthRt = 	hsBrthK * horses;	hsDthRt = 	hsDthK * horses;	horses +=		(hsBrthRt - hsDthRt);	horses = CLIP(horses);			/*	  * Compute changes in health this month	  */	 	slNourish = 	interpolate(slFed, &tSlNourish) * ARandom(1., 0.1);	slDiet = 		slNourish;		lashSick = 	interpolate(slLashRt, &tLashSick) * ARandom(1., 0.1);	slLabor = 		oxMult ? (wk_sl / oxMult) : 0;	wkSick = 		interpolate(slLabor, &tWkSick);	slSickRt = 	(slHealth <= 0) ? 0 : (wkSick + lashSick);	slHealth +=	(slDiet - slSickRt);	if (slHealth > 1)		slHealth = 1;	slHealth = 	CLIP(slHealth);		oxNourish = 	interpolate(oxFed, &tOxNourish) * ARandom(1., 0.1);	oxDiet = 		(oxHealth >= 1) ? 0 : oxNourish;	oxAge = 		(oxHealth <= 0) ? 0 : 0.05;	oxHealth +=	(oxDiet - oxAge);	oxHealth = 	CLIP(oxHealth);		hsNourish = 	interpolate(hsFed, &tHsNourish) * ARandom(1., 0.1);	hsDiet = 		(hsHealth >= 1 ) ? 0 : hsNourish;	hsAge = 		(hsHealth <= 0) ? 0 : 0.08;	hsHealth +=	(hsDiet - hsAge);	hsHealth = 	CLIP(hsHealth);		/*	  * How do the overseers feel about their job security?	  */	  	ovStress = 	(wkDeff_sl > 0) ? min(1, (wkDeff_sl/10)) : 0;	ovRelax = 	(wkDeff_sl > 0) ? 0 : (ovPress * 0.3);	ovPress +=	ovStress - ovRelax;		/*	  * Now adjust the market prices	  */	#define MARKET(x) 	((x) *= ARandom(1+inflation, .02))	  	inflation += GRandom(0.0, .001);	/* inflation rate takes a random walk */		MARKET(wtPrice);	MARKET(lnPrice);	MARKET(hsPrice);	MARKET(oxPrice);	MARKET(slPrice);	MARKET(mnPrice);	MARKET(ovPay);	MARKET(interest);		AdjustProduction(&lnSupply, &lnDemand, &lnProduction, &lnPrice);	AdjustProduction(&mnSupply, &mnDemand, &mnProduction, &mnPrice);	AdjustProduction(&wtSupply, &wtDemand, &wtProduction, &wtPrice);	AdjustProduction(&slSupply, &slDemand, &slProduction, &slPrice);	AdjustProduction(&hsSupply, &hsDemand, &hsProduction, &hsPrice);	AdjustProduction(&oxSupply, &oxDemand, &oxProduction, &oxPrice);		/* now lets look at overseer's salaries */		gold -= overseers * ovPay;		/* Monthly costs of ownership */	k1 =  	lnTotal * 100 +			slaves * 10 +			horses * 5 +			oxen * 3;	k1 *= ARandom(.7, .3) + .3; 	/* no less than .3 */	gold -= k1;	gold -= avgPyHeight * pyAdded;		/*	  * Now check the progress of the contracts	  */	  	ContProg();	/* are we overdrawn? */		if ((gold < 0) && (overseers > .5)) /*  we use .5 but we mean zero.  Floating roundoff */		{		TEXT msg[256];		DOUBLE x;		MessageStr(ST_CMPAY,  x=GRandom(20.0, 2.0)); 		overseers = 0;		ovPay += ovPay * x/100;		}			gold -= loan * (interest + intAddition)/100;		/* adjust credit rating */	if (loan > 0) /* if there is a loan outstanding */		{		creditRating *= .96;		intAddition *= 1.02;	/*increase interest a bit on general purposes. */		}	else		{		creditRating += (1-creditRating)/10;		intAddition *= 0.95;		}	/* Oops, defaulted on payments!! */	if (gold < 0)		{		MessageStr(ST_CMCASH); 		creditRating -= (1-creditRating)/3;		intAddition += .2;	/* bump interest by two tenths per month */		Loan((-gold) * 1.1); 	/* charge 5% emergency loan negotiation fee */		if (gold <= 0)			{			MessageStr(ST_CMRUPT); 			exit();			}				}	/* determine financial position */			netWth = 	slaves * slPrice + oxen * oxPrice + horses * hsPrice + 			lnTotal * lnPrice + manure * mnPrice + wheat * wtPrice + gold;	debt_asset = (netWth ? loan/netWth : 0);	netWth -= loan;	debtLimit = interpolate(creditRating, &tDebtSupport);	if (loan > 0)		{		if (debt_asset > debtLimit)	/* forclose */			{			MessageStr(ST_CMFCLS);			exit();			}				if (debt_asset > (debtLimit * .8))			{			MessageStr(ST_CMDBWN);			}		}	}/*«AdjustProduction»  * AdjustProduction -- figure out what the world production will adjust itself to.  */  VOID AdjustProduction(supply, demand, production, price)DOUBLE *supply, *demand, *production, *price;	{	DOUBLE monthlyDemand;		*demand *= 1+(worldGrowth/12);	/* demand grows at 5%/year */	monthlyDemand = *demand/12;	*supply -= monthlyDemand * .8;	if (*supply < 0)		{		*price *= URandom(1.0, 1.2);		*production *= URandom(1.0, 1.1);		}	*supply -= monthlyDemand * .2;		*supply = max(0.0, *supply);	if (*supply > 0)		{		*price *= URandom(.8, 1.0);		*production *= URandom(.9, 1.0);		}	*production *= URandom(.95, 1.05);	*supply += *production/12;	}