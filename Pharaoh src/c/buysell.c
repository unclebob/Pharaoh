/*  * BuySell.c -- This module contains all the functions which perform Buying and Selling transactions  */  #include <std.h>#include <quickdraw.h>#include <dialog.h>#include <event.h>#include <control.h>#include <math.h>#include "vars.h"#include "pharaoh.h"#include "random.h"#include "strings.h"/* local variables */BOOL buyFlag=NO, sellFlag=NO, keepFlag=NO, acquireFlag=NO;ControlHandle buyRb, sellRb, keepRb, acquireRb;/*ÇBuySellÈ  * BuySell -- control the buysell dialog box  */  VOID BuySell(rec)FAST BuySellRecord *rec;	{	DialogRecord d;	BITS item;	DOUBLE transAmt, transValue;	Rect r;		buyFlag = sellFlag = keepFlag = acquireFlag = NO;	ParamText(rec->name, "\P", "\P", "\P");	GetNewDialog(D_BS, &d, -1L);		GetDItem(&d, DIBS_BUY, &item, &buyRb, &r);	GetDItem(&d, DIBS_SELL, &item, &sellRb, &r);	GetDItem(&d, DIBS_KEEP, &item, &keepRb, &r);	GetDItem(&d, DIBS_ACQ, &item, &acquireRb, &r);			FOREVER		{		pascal short BSFilter();				ModalDialog(&BSFilter, &item);				if (item == DI_CANCEL)			break;		else if (item==DIBS_BUY || item==DIBS_SELL || item==DIBS_KEEP || item==DIBS_ACQ)			{			SetCtlValue(buyRb, buyFlag = (item==DIBS_BUY));			SetCtlValue(sellRb, sellFlag = (item==DIBS_SELL));			SetCtlValue(keepRb, keepFlag = (item==DIBS_KEEP));			SetCtlValue(acquireRb, acquireFlag = (item==DIBS_ACQ));			}		else if (item == DI_OK)			{			TEXT num[256]; /* dialog edits can't return anything bigger */			BITS x;			Handle editHandle;			DOUBLE atof(), newSupply, maxSupply;						GetDItem(&d, DIBS_EDIT, &x, &editHandle, &r);			GetIText(editHandle, &num);			ptoc(&num);						if (!IsNumeric(&num))				{				ErrorStr(ST_BSIN);	/* invalid number */				continue;				}							if (!(buyFlag || sellFlag || keepFlag || acquireFlag))				{				ErrorStr(ST_BSCF); /* please choose a function */ 				continue;				}							transAmt = atof(&num);			if (buyFlag)				transAmt = transAmt;	/* no change */			else if (sellFlag)				transAmt = -transAmt;			else if (keepFlag || acquireFlag)				transAmt -= *rec->value;						/* Now Check for errors */						/* we are really asking if we are trying to sell more than we have.  But			/* round off errors can sometimes make the difference very slightly negative.  We			/* accept this as a fact of life and allow slightly more to be sold than we own			/**/			if (*rec->value+transAmt < -1e-4) 				{				ErrorStr(ST_BSSELL, *rec->value);				SelIText(&d, DIBS_EDIT, 0, 32767);				continue; /* FOREVER */				}							if ((transAmt * *rec->price) > gold)				{				ErrorStr(ST_BSBUY, gold / *rec->price);				SelIText(&d, DIBS_EDIT, 0, 32767);				continue; /* FOREVER */				}						newSupply = *rec->supply - transAmt;			if (transAmt > 0 && newSupply < 0)				{				transAmt = max(*rec->supply, 1.0);				newSupply = 0;				MessageStr(ST_BSOUT, transAmt);				}						maxSupply = *rec->demand * 1.1;			if (transAmt < 0 && newSupply > maxSupply)				{				transAmt = -(maxSupply - *rec->supply);				transAmt = min(-1.0, transAmt);				newSupply = maxSupply;				MessageStr(ST_BSFULL, -transAmt);				}						*rec->supply = newSupply;						/* now adjust health if we are buying new animals/slaves */			if (rec->health && (transAmt > 0))				{				/* health of trade animals & slaves is nominally 0.8 */				DOUBLE nomHealth = GRandom(0.8, 0.02);				DOUBLE totHealth;								totHealth = transAmt * nomHealth + *rec->value * *rec->health;				*rec->health = totHealth/(transAmt + *rec->value);				}							/* burn any crops before selling the land they are on */			if (transAmt < 0 && rec->crop)				{				DOUBLE burnFract;								burnFract =  -transAmt / *rec->value;				*rec->crop *= 1- burnFract;				}							*rec->value += transAmt;			transValue = transAmt * *rec->price;						/* if we are selling, adjust market price by health of animal/slave */			if (rec->health && (transAmt < 0))				transValue *= *rec->health;	/* the market wont pay much for sickies */							gold -= transValue;			break;			}		}			CloseDialog(&d);	}		/*ÇBSFilterÈ  * BSFilter  -- 	the filter proc for the BuySell dialog.  Checks the flags to see if a function  * 				has been selected.  If not, the b,s,k or a keys will select one.  */  pascal short BSFilter(d, e, item)DialogPtr d;EventRecord *e;BITS *item;	{	if (e->what == keyDown && ((TEXT)e->message) == '\r')		{		*item = DI_OK;		return(pTRUE);		}	if (buyFlag || sellFlag || keepFlag || acquireFlag)		return(pFALSE);	if (e->what == keyDown)		{		TEXT c;		c = e->message;		c = tolower(c);		if (c == 'b')			{			*item = DIBS_BUY;			return(pTRUE);			}		if (c == 's')			{			*item = DIBS_SELL;			return(pTRUE);			}		if (c == 'k')			{			*item = DIBS_KEEP;			return(pTRUE);			}		if (c == 'a')			{			*item = DIBS_ACQ;			return(pTRUE);			}		return(pFALSE);		}	return(pFALSE);	}