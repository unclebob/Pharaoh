/*  * contract.c -- manage the contracts for the pharaoh  */  #include <std.h>#include <quickdraw.h>#include <math.h>#include "cells.h"#include "strings.h"#include "vars.h"#include "random.h"#include "contract.h"#include "contmenu.h"Contract	contOffers[MAXOFFERS],	/* currently offered contracts */		contPend[MAXPEND];	/* currently accepted contracts */Player 	players[MAXPLAYERS];	/* the contract players */TEXT *FmtFloat();/*«ClearContracts»  * ClearContracts -- Make sure all the contracts are inactive  */  VOID ClearContracts()	{	FAST COUNT i;		for (i=0; i<MAXOFFERS; i++)		contOffers[i].active = NO;	for (i=0; i<MAXPEND; i++)		contPend[i].active = NO;	}/*«MakePlayers»  * MakePlayers -- Set up all the initial contract players  */  VOID MakePlayers()	{	FAST COUNT i;		for (i=0; i<MAXPLAYERS; i++)		{		TEXT wrk[256];		GetIndCString(&wrk, ST_CNPLAY, i+1);		strncpy(&(players[i].name),wrk,sizeof(players[i].name));		players[i].name[sizeof(players[i].name)-1] = NULL;		players[i].payProb = MaxRandom(2, .5, 1.);		players[i].shipProb = MaxRandom(2, .5, 1.);		players[i].defProb = MaxRandom(5, .95, 1.);		}	}/*«PtrWhat»  * PtrWhat -- returns a pointer to a commodity, given its "what" code  */  DOUBLE *PtrWhat(what)FAST BITS what;	{	if (what == WHEAT)		return(&wheat);	else if (what == SLAVES)		return(&slaves);	else if (what == OXEN)		return(&oxen);	else if (what == HORSES)		return(&horses);	else if (what == MANURE)		return(&manure);	else if (what == LAND)		return(&lnFallow);	else		return(NIL);	}	/*«PtrHealthWhat»  * PtrHealthWhat -- returns a pointer to the health of a livestock commodity, or NIL if  *				what is not livestock.  */  DOUBLE *PtrHealthWhat(what)FAST BITS what;	{	if (what == WHEAT)		return(NIL);	else if (what == SLAVES)		return(&slHealth);	else if (what == OXEN)		return(&oxHealth);	else if (what == HORSES)		return(&hsHealth);	else if (what == MANURE)		return(NIL);	else if (what == LAND)		return(NIL);	else		return(NIL);	}	/*«AmountWhat»  * AmountWhat -- returns the amount of a commodity, given its "what" code  */  DOUBLE AmountWhat(what)FAST BITS what;	{	DOUBLE *ptr;		ptr = PtrWhat(what);	if (ptr == NIL)		return(0.0);	else		return(*ptr);	}/*«ValueWhat»  * ValueWhat -- returns the price of a commodity given its "what" code  */  DOUBLE ValueWhat(what)FAST BITS what;	{	if (what == WHEAT)		return(wtPrice);	else if (what == SLAVES)		return(slPrice);	else if (what == OXEN)		return(oxPrice);	else if (what == HORSES)		return(hsPrice);	else if (what == MANURE)		return(mnPrice);	else if (what == LAND)		return(lnPrice);	else		return(0.0);	}/*«TextWhat»  * TextWhat(what) -- return a pointer to the string which describes "what"  */  TEXT *TextWhat(what)FAST BITS what;	{	if (what == WHEAT)		return("bushells");	else if (what == SLAVES)		return("slaves");	else if (what == OXEN)		return("oxen");	else if (what == HORSES)		return("horses");	else if (what == MANURE)		return("tons");	else if (what == LAND)		return("acres");	else		return("tilt");	}	/*«AlreadyTrading»  * AlreadyTrading -- returns yes if the player is already trading in the specified goods  */  BOOL AlreadyTrading(who, what)FAST BITS who,what;	{	FAST COUNT n;	FAST Contract *c;		for (n=0; n<MAXOFFERS; n++)		{		c = &(contOffers[n]);		if ((c->who == who) && (c->what == what))			return(YES);		}	for (n=0; n<MAXPEND; n++)		{		c = &(contPend[n]);		if ((c->who == who) && (c->what == what))			return(YES);		}	return(NO);	}/*«MakeContract»  * MakeContract -- Fills a contract buffer with randomly selected contract contents  */  VOID MakeContract(contract)FAST Contract *contract;	{	DOUBLE workingAmount, minAmount, value, amount;	BITS who, what;		contract->who = -1;	/* invalidate this contract so it won't affect the search */	contract->what = -1;		do	/* search for a player and commodity who is not already trading. */		{		who = URandom(0.0, (DOUBLE)MAXPLAYER-.01);		what = URandom(1.0, 6.99);		} while (AlreadyTrading(who, what));		contract->who = who;	contract->what = what;	contract->type = (URandom(0., 1.) < .5) ? BUY : SELL;		value = ValueWhat(contract->what);	amount = AmountWhat(contract->what);	minAmount = 200000. / value;	workingAmount = GRandom(amount*6., amount*2.);	contract->amount = ceil(max(workingAmount, minAmount));		contract->price = ceil(contract->amount * value * (.4 + ERandom(.6)));	contract->duration = URandom(12., 36.);	contract->complete = 0.0;	contract->active = YES;	}/*«NewOffers»  * NewOffers -- 	Set up the contOffer array for a new month.  Kill some old contracts.  Fill all  *				empty slots.  Age the ones that are sticking around  */VOID NewOffers()	{	FAST COUNT i;		for (i=0; i<MAXOFFERS; i++)		{		if (contOffers[i].active)  /* this one is alive, should it be replaced? */			{			if (contOffers[i].duration <= 8 || URandom(0.0, 1.0) < .2)				MakeContract(&(contOffers[i]));			else	/* age the contract a little bit */				{ 				contOffers[i].duration--;				contOffers[i].price *= (contOffers[i].type == BUY) ? 									URandom(1.01, 1.1) :									URandom(.90, .99);				}			}		else			MakeContract(&(contOffers[i]));		}	}/*«ContFmt»  * ContFmt(c, b) -- format the contract pointed to by c into a text buffer pointed to by b  */  TEXT *ContFmt(c,b)FAST Contract *c;FAST TEXT *b;	{	TEXT amount[15], price[15];			sprintf(b, "%s will %s %s %s for %s in %d months.",			players[c->who].name, 			c->type == BUY ? "BUY" : "SELL",			FmtFloat(c->amount, &amount),			TextWhat(c->what),			FmtFloat(c->price,&price),			c->duration);	return(b);	}			/*«ContMenuSet»  * ContMenuSet -- Set up the contracts menu  */  VOID ContMenuSet()	{	FAST COUNT i,cmd;		NewOffers();		for (i=0, cmd=FIRSTCONT; cmd <= LASTCONT; i++, cmd++)		{		TEXT wrk[256];		FAST Contract *c;				c = &(contOffers[i]);		ContFmt(c, wrk);		ctop(wrk);		SetCmd(cmd, wrk);		if (c->active)			EnableCmd(cmd);		else			DisableCmd(cmd);		}	}/*«ContCell»  * ContCell(i) -- returns a pointer to the cell rectangle for the ith contract  */  Rect *ContCell(i)FAST COUNT i;	{	IMPORT Rect screenCells[XCELLS][YCELLS];	if (i==0) return(C_CONT1);	if (i==1) return(C_CONT2);	if (i==2) return(C_CONT3);	if (i==3) return(C_CONT4);	if (i==4) return(C_CONT5);	if (i==5) return(C_CONT6);	if (i==6) return(C_CONT7);	if (i==7) return(C_CONT8);	if (i==8) return(C_CONT9);	if (i==9) return(C_CONT10);	return(NIL);	}/*«PrintContracts»  * PrintContracts() -- Print all the contracts  */  VOID PrintContracts()	{	IMPORT Rect screenCells[XCELLS][YCELLS];	TEXT wrk[256];	FAST COUNT i;	TextFace(condenseStyle);		for (i=0; i<MAXPEND; i++)		{		if (contPend[i].active)			PrintCell(ContFmt(&(contPend[i]), &wrk), ContCell(i));		}	TextFace(0);	}/*«IncCommodity»  * IncCommodity -- 	Add the parameter to the commodity.  Adjust health if necessary, assume  *				 	that the new livestock have a health of .9.  */LOCAL VOID IncCommodity(what, x)BITS what;DOUBLE x;	{	FAST DOUBLE *amount, *health;	DOUBLE totHealth;		amount = PtrWhat(what);	health = PtrHealthWhat(what);		if (health)		{		totHealth = ((*health) * (*amount)) + (.9 * x);		*health = totHealth / (*amount + x);		}	*amount += x;	}	/*«ContProg»  * ContProg -- Measure the progress of the currently pending contracts  */  VOID ContProg()	{	FAST COUNT i;	FAST Contract *c;	FAST Player *p;	DOUBLE myAmount, *myPtr, ppu;		for (i=0; i<MAXPEND; i++)		{		c = &(contPend[i]);				if (c->active)			{			p = &(players[c->who]);			ppu = c->price / c->amount; /* price per unit */			if (p->defProb < URandom(0.0, 1.0)) /* defaulting */				{				ContMsg(c, ST_CNDFLT);				c->active = NO;				gold += c->price * .05; /* very small cancellation penalty */				continue;				}/* defaulting */							if (--(c->duration)<= 0)	/* is the contract due? */				{				if (c->type == BUY)	/* the contractee must buy */					{					DOUBLE canBuy;					if (p->payProb < URandom(0.0, 1.0))						canBuy = ceil(c->amount * URandom(.5, .95));					else						canBuy = c->amount;											myAmount = floor(AmountWhat(c->what));					if (myAmount < canBuy) /* got enough? */						{						ContMsg(c, ST_CNNENF);						c->price *= 1 - myAmount/c->amount;						c->amount -= myAmount;						gold += myAmount * ppu;	/* pay for it */						gold -= .1*c->price; /* subtract penalty */						*(PtrWhat(c->what)) = 0;						}/* myAmount < c->amount */					else if (canBuy < c->amount) /* oops, party of the first part screwed up */						{						ContMsg(c,ST_CNNBUY);						*(PtrWhat(c->what)) -= canBuy;						c->price *= 1 - canBuy/c->amount;						c->amount -= canBuy;						gold += canBuy * ppu + c->price * .1;						} /* canBuy < c->amount */					else /* he can buy it all */						{						ContMsg(c, ST_CNBUY);						*(PtrWhat(c->what)) -= canBuy;						gold += c->price;						c->active = NO;						}					} /*c->type == BUY */				else /* c->type == SELL */					{					DOUBLE canSell, sellPrice;					if (p->shipProb < URandom(0.0, 1.0))						canSell = ceil(c->amount * URandom(.5, .95));					else						canSell = c->amount;										sellPrice = canSell * ppu;										if (gold < sellPrice)	/* pharaoh does not have enough gold */						{						ContMsg(c, ST_CNNODO);						gold -= c->price * .1; /* deduct penalty */						myAmount = floor(max(gold,0.0) / ppu); /* what can I buy */						IncCommodity(c->what ,myAmount);						gold -= myAmount * ppu;						c->price *= 1 - myAmount/c->amount;						c->amount -= myAmount;						} /* gold < sellPrice */					else if (canSell < c->amount) /* contract issuer hasnt got the stuff */						{						ContMsg(c,ST_CNNSELL);						gold += c->price * .1;						gold -= canSell * ppu;						c->price *= 1 - canSell/c->amount;						c->amount -= canSell;						IncCommodity(c->what, canSell);						} /* canSell < c->amount */					else /* can sell */						{						ContMsg(c, ST_CNSELL);						gold -= c->price;						IncCommodity(c->what, c->amount);						c->active = NO;						}					}/* c->type == SELL */				}/* c->duration <= 0 */			} /* c->active */		} /* for i */	} /* ContProg */								/*«ContMsg»  * ContMsg(c, id) -- Display a contract message for contract 'c' and message 'id'  */  VOID ContMsg(c,id)FAST Contract *c;BITS id;	{	TEXT buf[256], string[256],amount[15];		GetCString(string, id);	sprintf(buf,"With reference to your contract with %s for %s %s: %s",			players[c->who].name,			FmtFloat(c->amount, amount),			TextWhat(c->what),			string);	MessageAlert(buf);	}	/*«ContCmd»  * ContCmd(cmd) -- Process a contract request  */  VOID ContCmd(cmd)BITS cmd;	{	FAST COUNT i;	TEXT buf[256], amount[15], price[15];	FAST Contract *c;		i = cmd - FIRSTCONT;	c = &(contOffers[i]);		for (i=0; i<MAXPEND; i++)		if (contPend[i].active == NO)			break;		if (i == MAXPEND)		{		MessageAlert("You have too many contracts already.");		return;		}	sprintf(buf,		"Will you %s %s %s %s %s for %s in %d months?",		c->type == BUY ? "sell" : "buy",		FmtFloat(c->amount,amount),		TextWhat(c->what),		c->type == BUY ? "to" : "from",		players[c->who].name,		FmtFloat(c->price, price),		c->duration);			if (QuerryAlert(buf))		{		movmem(c, &(contPend[i]), sizeof(Contract));		c->active = NO;		ContInval();		DisableCmd(cmd);		}	}	/*  * ContInval -- invalidate the contract rectangle  */  VOID ContInval()	{	Rect contRect;		contRect.top = CB_TLCN->top;	contRect.left = CB_TLCN->left;	contRect.bottom = CB_BRCN->bottom;	contRect.right = CB_BRCN->right;	InvalRect(&contRect);	}	