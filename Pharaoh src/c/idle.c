/*  * Idle.c -- This module handles the idling of the pharaoh window  */  #include <std.h>#include <quickdraw.h>#include <window.h>#include <event.h>#include <math.h>#include <macintalk.h>#include "vars.h"#include "random.h"#include "strings.h"#include "interpolate.h"#define MAN1	1000#define MAN2	1001#define MAN3	1002#define MAN4	1003IMPORT BOOL pgmLocked;		/* = NO if license fee has been paid */LONG	nextNag = 0L, 		/* the absolute time of the next nag */		nextDunn = 0L,		/* the absolute time of the next banking statement */		nextAd = 0L,		/* the absolute time of the next advertisement */		nextChat = 0L;		/* the absolute time of the next neighborly chat */		BOOL	nagCancel = YES,	/* should the current nag be cancelled */		dunnCancel = YES;	/* should the current dunning message be cancelled */		DOUBLE	banker = 0.0,			/* the resource of the banker */		goodGuy = 0.0,			/* the resource id of the truthSayer */		badGuy = 0.0,			/* the resource id of the liar */		dumbGuy = 0.0;			/* the resource id of the dummy */LOCAL Table dunnTime = 	/* number of seconds between bank notices */		{ 0.0, 1.0,	/* creditRating */		5., 6., 8., 12., 20., 30., 45., 60., 90., 200., 300.};		/*«Neighbor selection functions»  * ChooseMan -- Select one of the men at random  */  COUNT ChooseMan()	{	return(URandom(1000., 1003.9999));	}	/*  * SetMen -- Set each of the variables to a unique man  */  VOID SetMen()	{	banker = ChooseMan();	while ((goodGuy = ChooseMan()) == banker);	while ((badGuy = ChooseMan()) == banker || badGuy == goodGuy);	while((dumbGuy = ChooseMan()) == banker || dumbGuy == badGuy || dumbGuy == goodGuy);	}/*  * PhIdle -- keep track of time and put up the proper  alerts when necessary  */  VOID PhIdle(w)WindowRecord *w;	{	LOCAL LONG curTime=0, oldTime=0;		oldTime = curTime;	curTime = TickCount();		if (oldTime)	/* if this is not the first time through */		{		LONG delta;				delta = curTime - oldTime;		if (delta > 120) /* have more then two seconds elapsed? */			nagCancel = YES;	/* if so, then the player is doing something... */		}			/* Don't nag the guy if we have cancelled the nag, or if the window has changed. */	if (nagCancel || EmptyRgn(w->updateRgn) == TRUE)		{		nextNag = URandom(60.*60., 90.*60.) + curTime;		nagCancel = NO;		}	if (curTime > nextNag) /* should we nag? */		{		ManAlert(ChooseMan(), ST_IDLE);		nagCancel = YES;		}			if (dunnCancel || (curTime > nextDunn)) /* send next dunning notice */		{		if (nextDunn > 0 && loan > 0 && !dunnCancel)			ManAlert((BITS)banker, ST_DUNN);		nextDunn = curTime + interpolate(creditRating, &dunnTime) * 60.;		dunnCancel = NO;		}		if (curTime > nextChat)		{		if (nextChat > 0)			{			BITS man, ChooseChat();						man = ChooseMan();			ManAlert(man, ChooseChat(man));			}		nextChat = curTime + URandom(90., 200.) * 60.;		}		if (nextAd == 0L)		nextAd = curTime + 1800 * 60L;	else if (pgmLocked && (curTime > nextAd)) /* if the player is unlicensed */		{		BITS man;		man = ChooseMan();		ManAlert(man, ST_ADVERT);		nextAd = curTime + 120 * 60L;		}	}	/*«SelVoice»  * SelVoice -- Select the voice of the proper man  */  VOID SelVoice(id)BITS id;	{	IMPORT SpeechHandle theSpeech;		switch (id)		{		case MAN1:			SpeechRate(theSpeech, 100);			SpeechPitch(theSpeech, 200, Natural); 			break;					case MAN2:			SpeechRate(theSpeech, 150);			SpeechPitch(theSpeech, 66, Natural); 			break;					case MAN3:			SpeechRate(theSpeech, 200);			SpeechPitch(theSpeech, 100, Natural); 			break;					case MAN4:			SpeechRate(theSpeech, 250);			SpeechPitch(theSpeech, 150, Natural); 			break;					default:			SpeechRate(theSpeech, 190);			SpeechPitch(theSpeech, 310, Natural); 		}	}/*«ChooseChat»  * ChooseChat -- Choose which message we are going to chat about  */#define OXFEED		0#define SLFEED		1#define HSFEED		2#define OVERSEERS	3#define STRESS	4#define FERTILIZER	5#define SLHEALTH	6#define OXHEALTH	7#define HSHEALTH	8#define CREDIT		9BITS ChooseChat(man)FAST BITS man;	{	BITS topic, advice;		if (man == banker)		return(ST_CHAT);		if (URandom(0., 100.) < 20)		return(ST_CHAT);	/* there is a 20% chance that we will not be advising */			topic = URandom(0., 9.9999);	/* select a topic for advice */		advice = ST_CHAT;	/* just in case we don't find anything to say */	switch(topic)		{		case OXFEED:			if (oxen < 1)				return(ST_CHAT);			if (oxFeedRt < 50)				advice = ST_BDOXFD;			else if (oxFeedRt > 80)				advice = ST_GDOXFD;			break;					case HSFEED:			if (horses < 1)				return(ST_CHAT);			if (hsFeedRt < 40)				advice = ST_BDHSFD;			else if (hsFeedRt > 65)				advice = ST_GDHSFD;			break;					case SLFEED:			if (slaves < 1)				return(ST_CHAT);			if (slFeedRt < 5 && slHealth < .7)				advice = ST_BDSLFD;			else if (slFeedRt > 8 && slHealth > .8)				advice = ST_GDSLFD;			break;					case OVERSEERS:			if (overseers < 1)				return(ST_CHAT);			if (sl_ov > 30)				advice = ST_BDOV;			else if (sl_ov < 15)				advice = ST_GDOV;			break;					case STRESS:			if (overseers < 1)				return(ST_CHAT);			if (ovPress > .5)				advice = ST_BDST;			if (ovPress < .2)				advice = ST_GDST;			break;					case FERTILIZER:			if (lnTotal < 1)				return(ST_CHAT);			if (mn_ln < 2)				advice = ST_BDMN;			else if (mn_ln > 3.5 && mn_ln < 7)				advice = ST_GDMN;			break;						case SLHEALTH:			if (slaves < 1)				return(ST_CHAT);			if (slHealth < .6)				advice = ST_BDSLHL;			else if (slHealth > .9)				advice = ST_GDSLHL;			break;					case OXHEALTH:			if (oxen < 1)				return(ST_CHAT);			if (oxHealth < .5)				advice = ST_BDOXHL;			else if (oxHealth > .85)				advice = ST_GDOXHL;			break;					case HSHEALTH:			if (horses < 1)				return(ST_CHAT);			if (hsHealth < .5)				advice = ST_BDHSHL;			else if (hsHealth > .85)				advice = ST_GDHSHL;			break;					case CREDIT:			if (loan < 1)				return(ST_CHAT);			if (creditRating < .4)				advice = ST_BDCRED;			else if (creditRating > .8)				advice = ST_GDCRED;			break;		}		if (advice == ST_CHAT)		return(ST_CHAT);	/* if we couldn't find anything to say, then just chat */			if (man == badGuy)	/* is the liar talking? */		advice ^= 1;	/* flip the meaning of the advice */			if (man == dumbGuy)	/* is the villiage idiot talking? */		advice ^= ((BITS)URandom(0.,16.)) & 1;	/* randomize meaning */			/* now create a 95% accuracy rate for everyone */	if (URandom(0., 100.) > 95)		advice ^= 1;		return(advice);	}	